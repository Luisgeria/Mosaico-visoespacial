<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1, user-scalable=0" />
  <title>Mosaico visoespacial - Entrenamiento Cognitivo</title>
  <style>
    :root {
      --bg: #0b0f14;
      --panel: #121824;
      --card: #0f1520;
      --line: rgba(255, 255, 255, .12);
      --text: rgba(255, 255, 255, .92);
      --muted: rgba(255, 255, 255, .68);
      --accent: #6aa6ff;
      --success: #4ade80;
      --error: #f87171;
      --shadow: 0 12px 30px rgba(0, 0, 0, .35);
      --radius: 18px;
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    html, body { height: 100%; margin: 0; }
    
    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: radial-gradient(1200px 800px at 10% 0%, #172033 0%, var(--bg) 55%) fixed;
      color: var(--text);
      -webkit-font-smoothing: antialiased;
    }

    header {
      position: sticky; top: 0; z-index: 100;
      backdrop-filter: blur(12px);
      background: rgba(11, 15, 20, .85);
      border-bottom: 1px solid var(--line);
    }

    .wrap { max-width: 1200px; margin: 0 auto; padding: 14px; }

    .bar {
      display: flex; gap: 16px; align-items: center; justify-content: space-between; flex-wrap: wrap;
    }

    .title h1 { font-size: 1.2rem; margin: 0; color: var(--accent); }
    .title small { color: var(--muted); font-size: 0.85rem; }

    .controls { display: flex; gap: 8px; flex-wrap: wrap; }

    button, select {
      appearance: none;
      border: 1px solid var(--line);
      background: rgba(255, 255, 255, .05);
      color: var(--text);
      padding: 10px 14px;
      border-radius: 10px;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
    }

    /* Estilos específicos para el desplegable y sus opciones */
    select {
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='white'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M19 9l-7 7-7-7'%3E%3C/path%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 10px center;
      background-size: 14px;
      padding-right: 34px;
    }

    select option {
      background-color: #1e293b; /* Color de fondo oscuro para las opciones */
      color: white; /* Color de texto blanco para las opciones */
    }

    button:active { transform: scale(0.95); }
    .btn-primary { background: var(--accent); color: #000; font-weight: 600; border: none; }

    .grid {
      display: grid; grid-template-columns: 1fr 320px; gap: 20px;
      margin-top: 20px;
    }

    @media (max-width: 900px) {
      .grid { grid-template-columns: 1fr; }
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      display: flex; flex-direction: column;
      overflow: hidden;
    }

    .panel-head {
      padding: 12px 16px; border-bottom: 1px solid var(--line);
      display: flex; align-items: center; justify-content: space-between;
      background: rgba(255,255,255,0.02);
    }

    .panel-body { padding: 16px; flex: 1; }

    .boards-wrapper {
      display: flex; flex-wrap: wrap; gap: 30px; justify-content: center; align-items: flex-start;
    }

    .board-container {
      display: flex; flex-direction: column; align-items: center; gap: 10px; flex: 1; min-width: 260px;
    }

    .board-grid {
      aspect-ratio: 1/1; background: #000; border-radius: 12px;
      display: grid; 
      border: 4px solid #1e293b; position: relative;
      touch-action: none; 
      width: 100%;
      max-width: 420px;
      transition: transform 0.3s ease, border-color 0.3s;
    }

    .board-grid.win-anim {
      transform: scale(1.03);
      border-color: var(--success);
    }

    .cell { border: 1px solid rgba(255,255,255,.05); }

    .drop-slot {
      position: absolute; 
      border: 2px dashed transparent;
      pointer-events: none; box-sizing: border-box; z-index: 10;
    }
    .drop-slot.active { border-color: rgba(106, 166, 255, 0.3); }
    .drop-slot.highlight { border-color: var(--accent); background: rgba(106, 166, 255, 0.1); }

    .tray {
      display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 12px;
    }

    .piece {
      aspect-ratio: 1/1; border-radius: 8px; cursor: pointer;
      display: grid; 
      border: 2px solid rgba(255,255,255,.1); overflow: hidden;
      touch-action: none; 
      user-select: none;
    }

    .piece.dragging { 
      position: fixed; z-index: 9999; pointer-events: none; 
      width: 90px; height: 90px; opacity: 0.9;
      transform: translate(-50%, -120%); 
    }
    .piece.hidden { opacity: 0.1; pointer-events: none; }

    .q { border: 0.5px solid rgba(128,128,128,0.1); pointer-events: none; }
    .q.b { background: #000; }
    .q.w { background: #fff; }

    .status-msg { font-weight: bold; font-size: 14px; transition: all 0.3s; }
    .status-msg.ok { color: var(--success); transform: scale(1.05); }
    .status-msg.error { color: var(--error); }

    .help-text { font-size: 12px; color: var(--muted); margin-top: 15px; text-align: center; line-height: 1.4; }
    
    .label-tag { font-size: 11px; font-weight: 600; color: var(--muted); text-transform: uppercase; letter-spacing: 0.05em; }
  </style>
</head>
<body>

<header>
  <div class="wrap">
    <div class="bar">
      <div class="title">
        <h1>Mosaico Visoespacial</h1>
        <small id="game-desc">Replica el patrón usando 4 piezas</small>
      </div>
      <div class="controls">
        <select id="level-select">
          <!-- Generado dinámicamente -->
        </select>
        <button id="btn-reset">Reiniciar</button>
        <button id="btn-check" class="btn-primary">Validar</button>
      </div>
    </div>
  </div>
</header>

<main class="wrap">
  <div class="grid">
    <section class="panel">
      <div class="panel-head">
        <span id="feedback" class="status-msg">Selecciona una pieza</span>
        <button id="btn-toggle-model" style="padding:4px 8px; font-size:11px">Ocultar Modelo</button>
      </div>
      <div class="panel-body">
        <div class="boards-wrapper">
          <div class="board-container">
            <span class="label-tag">Tu Tablero</span>
            <div id="main-board" class="board-grid"></div>
          </div>
          <div class="board-container" id="model-container">
            <span class="label-tag">Modelo a Replicar</span>
            <div id="model-board" class="board-grid" style="max-width:200px; border-color: #334155; opacity: 0.9;"></div>
          </div>
        </div>
        <p class="help-text" id="controls-help">
          <b>Click/Tap:</b> Rotar. <b>Arrastrar:</b> Colocar. <b>Doble Tap:</b> Quitar.
        </p>
      </div>
    </section>

    <aside class="panel">
      <div class="panel-head">
        <span>Bandeja de Piezas</span>
        <span id="counter" style="font-size:12px; opacity:0.6">0 / 4</span>
      </div>
      <div class="panel-body" id="tray-container" style="max-height: 500px; overflow-y:auto;">
        <div class="tray" id="tray"></div>
      </div>
    </aside>
  </div>
</main>

<script>
  // Modelos de 1 a 20
  // 1-10 son 4x4 (16 celdas)
  // 11-20 son 6x6 (36 celdas)
  const MODELS = {
    1: [0,0,0,0, 0,1,1,0, 0,1,1,0, 0,0,0,0],
    2: [1,0,0,1, 0,0,0,0, 0,0,0,0, 1,0,0,1],
    3: [1,1,1,1, 1,0,0,1, 1,0,0,1, 1,1,1,1],
    4: [1,0,1,0, 0,1,0,1, 1,0,1,0, 0,1,0,1],
    5: [1,1,0,0, 1,1,0,0, 0,0,1,1, 0,0,1,1],
    6: [1,0,0,1, 1,0,0,1, 0,1,1,0, 0,1,1,0],
    7: [1,1,1,1, 0,0,0,0, 1,1,1,1, 0,0,0,0],
    8: [0,1,1,0, 1,1,1,1, 1,1,1,1, 0,1,1,0],
    9: [1,0,1,1, 0,0,1,0, 0,1,0,0, 1,1,0,1],
    10: [1,1,0,1, 1,0,0,0, 0,0,0,1, 1,0,1,1],
    // Niveles 11-20: Tablero 6x6
    11: [0,0,0,0,0,0, 0,1,1,1,1,0, 0,1,0,0,1,0, 0,1,0,0,1,0, 0,1,1,1,1,0, 0,0,0,0,0,0],
    12: [1,1,0,0,1,1, 1,1,0,0,1,1, 0,0,1,1,0,0, 0,0,1,1,0,0, 1,1,0,0,1,1, 1,1,0,0,1,1],
    13: [1,0,1,0,1,0, 0,1,0,1,0,1, 1,0,1,0,1,0, 0,1,0,1,0,1, 1,0,1,0,1,0, 0,1,0,1,0,1],
    14: [1,1,1,0,0,0, 1,1,1,0,0,0, 1,1,1,0,0,0, 0,0,0,1,1,1, 0,0,0,1,1,1, 0,0,0,1,1,1],
    15: [1,0,0,0,0,1, 0,1,0,0,1,0, 0,0,1,1,0,0, 0,0,1,1,0,0, 0,1,0,0,1,0, 1,0,0,0,0,1],
    16: [0,0,1,1,0,0, 0,1,1,1,1,0, 1,1,1,1,1,1, 1,1,1,1,1,1, 0,1,1,1,1,0, 0,0,1,1,0,0],
    17: [1,1,1,1,1,1, 1,0,0,0,0,1, 1,0,1,1,0,1, 1,0,1,1,0,1, 1,0,0,0,0,1, 1,1,1,1,1,1],
    18: [1,0,1,0,1,0, 1,1,1,1,1,1, 1,0,1,0,1,0, 0,1,0,1,0,1, 1,1,1,1,1,1, 0,1,0,1,0,1],
    19: [1,1,0,0,1,1, 1,0,0,0,0,1, 0,0,1,1,0,0, 0,0,1,1,0,0, 1,0,0,0,0,1, 1,1,0,0,1,1],
    20: [0,1,0,1,0,1, 1,0,1,0,1,0, 0,1,1,1,1,0, 0,1,1,1,1,0, 1,0,1,0,1,0, 0,1,0,1,0,1]
  };

  let currentLevel = 1;
  let trayPieces = [];
  let placedPieces = []; 
  let quadrants = [];
  let dragData = null;
  let isTransitioning = false;
  let boardSize = 4; // 4 o 6
  let pieceSize = 2; // 2 o 3

  function init() {
    const select = document.getElementById('level-select');
    for(let i=1; i<=20; i++) {
      const opt = document.createElement('option');
      opt.value = i;
      opt.textContent = `Nivel ${i}`;
      select.appendChild(opt);
    }
    
    setupLevel(1);
    setupGlobalEvents();
  }

  function setupLevel(level) {
    currentLevel = parseInt(level);
    isTransitioning = false;
    document.getElementById('level-select').value = currentLevel;
    
    // Determinar dimensiones según el nivel
    if (currentLevel <= 10) {
      boardSize = 4;
      pieceSize = 2;
      quadrants = [
        { id: 0, r: 0, c: 0 }, { id: 1, r: 0, c: 2 },
        { id: 2, r: 2, c: 0 }, { id: 3, r: 2, c: 2 }
      ];
      document.getElementById('game-desc').textContent = "Tablero 4x4 | Piezas 2x2";
    } else {
      boardSize = 6;
      pieceSize = 3;
      quadrants = [
        { id: 0, r: 0, c: 0 }, { id: 1, r: 0, c: 3 },
        { id: 2, r: 3, c: 0 }, { id: 3, r: 3, c: 3 }
      ];
      document.getElementById('game-desc').textContent = "Tablero 6x6 | Piezas 3x3";
    }

    placedPieces = new Array(quadrants.length).fill(null);
    const targetPattern = MODELS[currentLevel];
    trayPieces = [];

    // 1. Extraer las piezas correctas de la solución
    quadrants.forEach((q, idx) => {
      let pPattern = [];
      for(let r=0; r<pieceSize; r++) {
        for(let c=0; c<pieceSize; c++) {
          pPattern.push(targetPattern[(q.r + r) * boardSize + (q.c + c)]);
        }
      }
      trayPieces.push({
        id: `sol-${idx}`,
        pattern: pPattern,
        size: pieceSize
      });
    });

    // 2. Añadir piezas de distracción (8 piezas extra)
    for (let i = 0; i < 8; i++) {
      let randomPattern = Array.from({length: pieceSize * pieceSize}, () => Math.round(Math.random()));
      trayPieces.push({
        id: `extra-${i}`,
        pattern: randomPattern,
        size: pieceSize
      });
    }

    trayPieces.sort(() => Math.random() - 0.5);
    renderAll();
  }

  function renderAll() {
    renderBoard();
    renderModel();
    renderTray();
    const fb = document.getElementById('feedback');
    fb.textContent = "Nivel " + currentLevel;
    fb.className = "status-msg";
    document.getElementById('main-board').classList.remove('win-anim');
  }

  function renderBoard() {
    const board = document.getElementById('main-board');
    board.style.gridTemplateColumns = `repeat(${boardSize}, 1fr)`;
    board.innerHTML = '';
    
    for (let i = 0; i < boardSize * boardSize; i++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.id = `cell-${i}`;
      board.appendChild(cell);
    }

    quadrants.forEach(q => {
      const slot = document.createElement('div');
      slot.className = 'drop-slot';
      slot.dataset.qid = q.id;
      slot.style.width = (pieceSize / boardSize * 100) + '%';
      slot.style.height = (pieceSize / boardSize * 100) + '%';
      slot.style.top = (q.r / boardSize * 100) + '%';
      slot.style.left = (q.c / boardSize * 100) + '%';
      board.appendChild(slot);
    });
    updateBoardColors();
  }

  function renderModel() {
    const modelBoard = document.getElementById('model-board');
    modelBoard.style.gridTemplateColumns = `repeat(${boardSize}, 1fr)`;
    modelBoard.innerHTML = '';
    MODELS[currentLevel].forEach(v => {
      const c = document.createElement('div');
      c.className = `cell ${v ? 'q b' : 'q w'}`;
      modelBoard.appendChild(c);
    });
  }

  function renderTray() {
    const tray = document.getElementById('tray');
    tray.innerHTML = '';
    trayPieces.forEach(p => {
      const isUsed = placedPieces.some(placed => placed?.id === p.id);
      const el = createPieceUI(p);
      if (isUsed) el.classList.add('hidden');
      tray.appendChild(el);
    });
    document.getElementById('counter').textContent = `${placedPieces.filter(Boolean).length} / ${quadrants.length}`;
  }

  function createPieceUI(piece) {
    const el = document.createElement('div');
    el.className = 'piece';
    el.dataset.id = piece.id;
    el.style.gridTemplateColumns = `repeat(${piece.size}, 1fr)`;
    piece.pattern.forEach(v => {
      const q = document.createElement('div');
      q.className = `q ${v ? 'b' : 'w'}`;
      el.appendChild(q);
    });
    return el;
  }

  function updateBoardColors() {
    for (let i = 0; i < boardSize * boardSize; i++) {
      const cell = document.getElementById(`cell-${i}`);
      if (cell) cell.style.background = '';
    }
    placedPieces.forEach((p, qIdx) => {
      if (!p) return;
      const q = quadrants[qIdx];
      const start = q.r * boardSize + q.c;
      
      p.pattern.forEach((v, i) => {
        const localR = Math.floor(i / pieceSize);
        const localC = i % pieceSize;
        const cellIdx = (q.r + localR) * boardSize + (q.c + localC);
        const cell = document.getElementById(`cell-${cellIdx}`);
        if (cell) cell.style.background = v ? '#000' : '#fff';
      });
    });
  }

  function rotateArray(arr, size) {
    const newArr = new Array(size * size);
    for (let r = 0; r < size; r++) {
      for (let c = 0; c < size; c++) {
        newArr[c * size + (size - 1 - r)] = arr[r * size + c];
      }
    }
    return newArr;
  }

  function setupGlobalEvents() {
    document.addEventListener('pointerdown', e => {
      if (isTransitioning) return;
      const pieceEl = e.target.closest('.piece');
      if (!pieceEl || pieceEl.classList.contains('hidden')) return;

      const id = pieceEl.dataset.id;
      const ghost = pieceEl.cloneNode(true);
      ghost.classList.add('dragging');
      document.body.appendChild(ghost);

      dragData = {
        id: id,
        el: ghost,
        startX: e.clientX,
        startY: e.clientY,
        moved: false,
        pointerId: e.pointerId
      };

      pieceEl.setPointerCapture(e.pointerId);
      updateGhost(e.clientX, e.clientY);
      document.querySelectorAll('.drop-slot').forEach(s => s.classList.add('active'));
    });

    document.addEventListener('pointermove', e => {
      if (!dragData) return;
      if (Math.abs(e.clientX - dragData.startX) > 8 || Math.abs(e.clientY - dragData.startY) > 8) {
        dragData.moved = true;
      }
      updateGhost(e.clientX, e.clientY);

      document.querySelectorAll('.drop-slot').forEach(slot => {
        const r = slot.getBoundingClientRect();
        const over = e.clientX > r.left && e.clientX < r.right && e.clientY > r.top && e.clientY < r.bottom;
        slot.classList.toggle('highlight', over);
      });
    });

    document.addEventListener('pointerup', e => {
      if (!dragData) return;
      
      if (!dragData.moved) {
        rotatePiece(dragData.id);
      } else {
        const slot = document.querySelector('.drop-slot.highlight');
        if (slot) {
          const qid = slot.dataset.qid;
          if (!placedPieces[qid]) {
            const original = trayPieces.find(p => p.id === dragData.id);
            placedPieces[qid] = JSON.parse(JSON.stringify(original));
            renderTray();
            updateBoardColors();
          }
        }
      }

      dragData.el.remove();
      dragData = null;
      document.querySelectorAll('.drop-slot').forEach(s => s.classList.remove('active', 'highlight'));
    });

    document.addEventListener('dblclick', e => {
      if (isTransitioning) return;
      const slot = e.target.closest('.drop-slot');
      if (slot) {
        placedPieces[slot.dataset.qid] = null;
        renderTray();
        updateBoardColors();
      }
    });

    document.getElementById('level-select').onchange = (e) => setupLevel(e.target.value);
    document.getElementById('btn-reset').onclick = () => setupLevel(currentLevel);
    document.getElementById('btn-check').onclick = checkSolution;
    document.getElementById('btn-toggle-model').onclick = function() {
      const c = document.getElementById('model-container');
      const isVisible = window.getComputedStyle(c).display !== 'none';
      c.style.display = isVisible ? 'none' : 'flex';
      this.textContent = isVisible ? 'Mostrar Modelo' : 'Ocultar Modelo';
    };
  }

  function updateGhost(x, y) {
    if (dragData) {
      dragData.el.style.left = x + 'px';
      dragData.el.style.top = y + 'px';
    }
  }

  function rotatePiece(id) {
    const pInTray = trayPieces.find(x => x.id === id);
    if (!pInTray) return;
    pInTray.pattern = rotateArray(pInTray.pattern, pieceSize);
    
    placedPieces.forEach(placed => {
      if (placed && placed.id === id) placed.pattern = [...pInTray.pattern];
    });
    renderTray();
    updateBoardColors();
  }

  function checkSolution() {
    if (isTransitioning) return;
    const fb = document.getElementById('feedback');
    const board = new Array(boardSize * boardSize).fill(null);
    
    placedPieces.forEach((p, qIdx) => {
      if (!p) return;
      const q = quadrants[qIdx];
      p.pattern.forEach((v, i) => {
        const localR = Math.floor(i / pieceSize);
        const localC = i % pieceSize;
        const cellIdx = (q.r + localR) * boardSize + (q.c + localC);
        board[cellIdx] = v;
      });
    });

    if (board.includes(null)) {
      fb.textContent = "¡Mosaico incompleto!";
      fb.className = "status-msg error";
      return;
    }

    const win = board.every((v, i) => v === MODELS[currentLevel][i]);
    if (win) {
      fb.textContent = "¡Correcto! Avanzando...";
      fb.className = "status-msg ok";
      document.getElementById('main-board').classList.add('win-anim');
      isTransitioning = true;
      
      setTimeout(() => {
        if (currentLevel < 20) {
          setupLevel(currentLevel + 1);
        } else {
          fb.textContent = "¡MAESTRO DEL MOSAICO COMPLETADO!";
          fb.className = "status-msg ok";
          isTransitioning = false;
        }
      }, 1500);
      
    } else {
      fb.textContent = "No coincide. Verifica la rotación.";
      fb.className = "status-msg error";
    }
  }

  init();
</script>

</body>
</html>
